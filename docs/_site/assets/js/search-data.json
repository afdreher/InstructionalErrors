{"0": {
    "doc": "Rotation",
    "title": "Rotation",
    "content": "Be a yardstick of quality. Some people aren’t used to an environment where excellence is expected. – Steve Jobs . Anything Apple-related has to start with Steve Jobs. I think it’s a rule or something. I believe that attention to detail in the UI is a critical part of being that yardstick of quality. I’ve long been fascinated by user interfaces and human perception because it’s the layer at which the magic occurs. Advanced but inaccessible technology is… well… unusable technology. And that’s part of why I love mobile technology so much: it is simultaneously ubiquitous and personal, able to be a personal guide, entertainment on long journeys, and connections across cultures. Crafting enchanting experiences brings innovation to the mass market in a way few other platforms can. So, what happens, though, when that spell breaks? It results in disappointment at the very least. Although this may be a quixotic folly and I just tilting at windmills, one of my signals of quality is how applications handle rotations, which can generally be succinctly summarized: poorly. Rotations are perhaps the fairy-tale stepchildren of the UI world: they’re needy and often ignored, but if handled correctly, they grow into a thing of beauty. They are among my favorite ways of breaking the user experience, and these issues of this variety often escape in the wild. It’s frustrating because it is an overlooked but important part of user engagement. Here, I’d like to provide some instances and ideas on how designers and developers can, together, recover that magic — all at very reasonable costs. Because I spend most of my time on iOS, this article will discuss iOS idioms and API. However, it is relevant for any mobile platform. I want to be clear that all of the examples shown here are simply representatives of problems I’ve found in live production apps. I am not trying to single out these companies, and I have no insider information. With that in mind, let’s start exploring some errors. There are two main errors I want to currently focus on with regard to rotation: . | Maps This is a fascinating study in design choices and possible workarounds for SDK glitches | Layer Separation A common issue with rotation is that apps incorrectly handle the layers and layout changes upon rotation. | . ",
    "url": "/rotation/",
    
    "relUrl": "/rotation/"
  },"1": {
    "doc": "Home",
    "title": "Home",
    "content": "This is my personal collection of fun glitches I’ve found “in the wild” with live production applications. This collections is meant to be instructive; it is not meant to shame any individuals or organizations. Errors happen. Embrace Kaizen. :man_facepalming: . The current focus is on rotational issues, but more will be added over time. ",
    "url": "/",
    
    "relUrl": "/"
  },"2": {
    "doc": "Layer Separation",
    "title": "Layer Separation",
    "content": "I mentioned previously that rotation is one of my favorite ways of breaking the user experience on mobile. These errors are easy to miss in production in part because they are transitory. Designers provide developers with the endpoints, such as a portrait and a landscape layout, and occasionally describe what needs to happen in between (obviously, some are much better at this than others). It is easy to verify that both endpoints are satisfied, especially with automated testing; however, the in-between animation is often a different story. Unfortunately, at least for me, the magic of mobile and of iOS, in particular, is that fluid and interactive experience. Case Study: Netflix . I want to premise that this is a harmless error, but it is an example of this error category. The code reproducing the error and possible corrections are available as the rotation demo in the InstructionalErrors repository. What is this error? Upon launching the iOS application, users are greeted with a static “N” logo, which subsequently animates to reveal the full “Netflix” branding before transitioning to the main menu screen. Yet, a fun glitch occurs when an iPad is rotated immediately after launch (see Figure 1, below). Figure 1. Example frames taken from the Netflix iOS application for iPad captured in late August 2024. This glitch, while not new, persists in the latest version, 16.51.0 (20). When the iPad is rotated, the static “N” and dynamic “Netflix” split apart, exposing not only that they are rendered as separate layers but also that the positioning calculations are distinctly different. This visual separation disrupts the seamless transition from the “N” to “Netflix.” While the static “N” is correctly centered on the screen, the dynamic animation for “Netflix” appears misaligned. Given the non-square dimensions of the iPad screen (3:4 for the full-sized model and 3:2 for the mini), this suggests that the dynamic logo’s position is calculated when the view is first loaded, whereas the static logo’s position is correctly updated during the subview layout. Case Study: Claude . Anthropic’s Claude app has a slew of inconsistencies and UX glitches – enough for a decent case study. This might be considered somewhat ironic given the push for automated coding, but for now, I will focus solely on one due to rotation. Figure 2. Example frames taken in February 2025 while rotating the Claude app [1.250127.0 (12938027910)] from landscape to portrait . Figure 2 displays an error similar to that shown in Figure 1, except that the flaws are even deeper because the individual view components are poorly contained. To clarify, many things are going awry here – having the keyboard show exacerbates the issues. The forced redraw causes three issues: . | Because the hero avatar is laid out independently from the welcome label, the avatar makes a U-shaped path starting in the upper left of the landscape layout, sliding toward the center, and finally sliding up to the top center of the portrait layout. This is not the expected direction. The avatar should enter horizontally centered from below the input sheet at the bottom of the screen, just above, and simultaneously with, the welcome label. | The welcome label makes a brief “peek-a-boo” appearance in the lower center before the sliding animation. This type of flash glitch is typically distracting. | The user input sheet is completely redrawn rather than animated smoothly in its new position. | . Experiment: Vibe Coding with LLMs . One cannot expect to be taken seriously these days without mentioning AI / LLM technology, so consider that done. :heavy_check_mark: . This is a very cursory look and does not represent any systematic investigation into code generation quality. The curious can find many better benchmarks. Nonetheless, given how often rotation causes issues for presumably sophisticated developers, I was curious how different language models would handle them. I chose three cloud providers (Anthropic, Google, Microsoft, and SambaNova) as well as one local instance of Llama. It is undoubtedly unfair to pit the Llama 8B small language model (SLM) model against the online providers (LLM). Still, it’s interesting because running it locally can allow one to potentially ask the language model for help without potentially releasing secrets to a cloud provider, providing developers with an attractive entry. Please create a UIView and associated UIViewController for iOS to serve as a splash screen that has two subviews, representing a “static” and a “dynamic” logo. These subviews should be centered inside the primary view and the z-index of the static logo view above that of the dynamic one. When the view finishes appearing on the screen, the dynamic logo view should slowly (e.g., 2 seconds) fade into view. Because the art department has not yet completed the real assets, please represent the static logo as a red rectangle of size 250 pixels wide by 350 pixels tall, and the dynamic logo as an orange rectangle of size 380 pixels wide and 350 pixels tall. Note that the prompt is purposefully ambiguous and omits some details (e.g., not specifying the use of constraints or the background color for the main view). It also eschews hinting about rotation awareness. These omissions are to test the ability of the LLMs to generate code from incompletely specified prompts. Repository . These examples can be built using the targets: . | LLM-Claude (Anthropic) | LLM-Copilot (Microsoft) | LLM-Gemini (Google) | LLM-Llama8B (Meta / Ollama) | LLM-Llama405B (Meta / SambaNova) | . Results . | Model | Compiles? | Correct? | Constraint-Based? | UIView + VC? | . | Claude | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :x: | . | Copilot (Feb) | :heavy_check_mark: | :x: | :x: | :heavy_check_mark: | . | Copilot (Mar) | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :x: | . | Gemini | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :x: | . | Llama 8B | :x: | :x: | :x: | :x: | . | Llama 405B | :heavy_check_mark: | :x: | :heavy_check_mark: | :x: | . Correctness . Both Anthropic and Google generated code that utilized NSLayoutConstraints and behaved as expected. I would hand the nod to Google’s code generation, though, because, for me, stylistically, I like having the translatesAutoresizingMask = NO close to where the new constraints are added. Stylistic concerns . Of the remaining two, of course, the Llama model made more errors, inventing code that isn’t part of the language / API. Nonetheless, it does have some positives over the other alternatives, such as breaking the constants out of the code. Both the Llama 8B and the Microsoft Copilot models generated code that did not have the views in the correct paint order. However, once corrected, they might be passed as acceptable. Yet, if one rotates the view, one can see that the layers split, similar to that in the Netflix example. For all of these examples, extra technical documentation and full code examples are provided on my GitHub page as the rotation demo in the InstructionalErrors repository. ",
    "url": "/rotation/layers",
    
    "relUrl": "/rotation/layers"
  },"3": {
    "doc": "Maps",
    "title": "Maps Rotation Issues",
    "content": "The maps apps from both Apple and Google provide a great starting point for discussing the design aspects of rotation. Map apps are such an appealing case study because their primary purpose is to orient a user in some space. Abstractly, animations serve the same purpose. By smoothly transitioning the UI, we keep the user oriented in our app. Consequently, one might expect that maps apps apply this orientation concept ruthlessly. However, that would be incorrect. Case Study: Apple Maps . Figure 1. Movie demonstrating the behavior of Apple Maps when rotating the device. The important part to watch is the last few frames where the map snaps to a new location. This behavior is seen regardless of the chosen basemap. It is difficult to show in isolated frames, but the issue with the Apple Maps animation is that there is essentially a jump cut transition to the new map position at the end of the animation. As demonstrated in the Example Code, this is likely due to a glitch somewhere inside the class cluster supporting MKMapView. Case Study: Google Maps . Figure 2. Movie demonstrating the behavior of Google Maps when rotating the device. For the most part, the rotation is as one would expect. However, one can notice a momentary flash during the rotation. This flash occurs because the background color for the view hosting the map images is set to white and the map is resized / redrawn immediately when the rotation begins rather than either computing the maximum bounds or deferring the resize until the rotation completes. Two frames captured mid rotation (Figure 3) show the effect. Figure 3. Example frames captured mid rotation showing the white background and eager resizing of the map view. In Figure 3, notice in the left image that the white background is exposed below the search bar. Contrast this with the start of Figure 2, where the imagery clearly extends below this bar. In the right image, notice that the card displaying information about the point of interest extends to the bottom edge of the screen on the left of the display, while on the right of the display, there is a large white region below the edge of the map imagery. Also, note that the imagery now extends below the search bar in contrast with that of the early part of the rotation in the left image. The obvious fixes for the issue shown in Figure 3 are: . | Set the background of the containing view to black since this matches the system behavior for the background outside the rotating view and thus would be less noticeable, even though this does not account for the resize issue. | Resize the map to support the maximum necessary region for the rotation, allowing the window to clip the view. Perform the final resize upon the completion of the animation. | . Example Code . Example code is provided in the InstructionalErrors repository which demonstrates both the Google Maps style sequential animation as well as the proposed simultaneous animation, which moves the POI to the correct spot along with the rotation. Do not use the simultaneous animation for production code. When animationOrder = .simultaneous, there is a glitch in MKMapView that will occasionally cause the zoom level to change abruptly when the device rotates from Portrait to Landscape. Interestingly, the change from Landscape to Portrait does not seem to be impacted. Unfortunately, the post-rotation slide / refresh largely remains. One can certainly ask if this behavior is related to the point of interest (POI) selection. The answer is no. Switching from profile to landscape, both apps place the previous center position, represented approximately by the POI in the right-hand side clear space. While Google Maps animates this transition, Apple Maps uses a hard redraw as seen in Figure 1. It is entirely possible to force the redraw during the rotation animation. However, the specifics of doing so are beyond the focus of this page since doing so requires a deep dive into the Core Animation framework. From a technical standpoint, animating the UI on rotation, including the map, should be straightforward. All that should be needed is to provide an implementation of viewWillTransition(to:with:), make the required call to super, ensuring that all of the default animations take place, and then call coordinator.animate(alongsideTransition:), optionally with a completion handler. ",
    "url": "/rotation/maps#maps-rotation-issues",
    
    "relUrl": "/rotation/maps#maps-rotation-issues"
  },"4": {
    "doc": "Maps",
    "title": "Maps",
    "content": " ",
    "url": "/rotation/maps",
    
    "relUrl": "/rotation/maps"
  }
}
